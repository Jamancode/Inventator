<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Smart Inventar Organizer Pro</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --success: #059669;
            --warning: #d97706;
            --error: #dc2626;
            --surface: #ffffff;
            --surface-alt: #f8fafc;
            --border: #e2e8f0;
            --text: #0f172a;
            --text-muted: #64748b;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --radius: 12px;
            --transition: all 0.3s ease;
            --slider-track: #e2e8f0;
            --slider-thumb: #2563eb;
            --tree-line: #cbd5e1;
        }

        [data-theme="dark"] {
            --surface: #0f172a;
            --surface-alt: #1e293b;
            --border: #334155;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --slider-track: #334155;
            --tree-line: #475569;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--surface-alt) 0%, var(--surface) 100%);
            color: var(--text);
            min-height: 100vh;
            transition: var(--transition);
            overflow-x: hidden;
            touch-action: manipulation;
        }

        /* Mobile First Layout */
        .container {
            padding: 1rem;
            max-width: 100%;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 2rem;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        @media (min-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
        }

        .header p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Mobile-optimized voice controls */
        .voice-section {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .mic-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            font-size: 2.5rem;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .mic-button:active {
            transform: scale(0.95);
        }

        .mic-button.listening {
            animation: pulse 1.5s infinite;
            background: linear-gradient(135deg, var(--error) 0%, #dc2626 100%);
        }

        .mic-button.processing {
            background: linear-gradient(135deg, var(--warning) 0%, #ea580c 100%);
        }

        .mic-button.speaking {
            background: linear-gradient(135deg, var(--success) 0%, #047857 100%);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(37, 99, 235, 0.6); }
        }

        .status {
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        /* Mobile-optimized input */
        .search-container {
            position: relative;
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            color: var(--text);
            font-size: 1.1rem;
            touch-action: manipulation;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        /* Quick action buttons for mobile */
        .quick-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: var(--radius);
            background: var(--primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--surface-alt);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-icon {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            font-size: 1.2rem;
            padding: 0;
        }

        /* Collapsible sections for mobile */
        .section {
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .section-header {
            padding: 1rem;
            background: var(--surface-alt);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            touch-action: manipulation;
        }

        .section-content {
            padding: 1rem;
            display: none;
        }

        .section-content.active {
            display: block;
        }

        .expand-icon {
            transition: var(--transition);
            font-size: 1.2rem;
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        /* Form styling */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }

        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            color: var(--text);
            font-size: 1rem;
            transition: var(--transition);
            touch-action: manipulation;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        @media (min-width: 640px) {
            .input-group {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (min-width: 768px) {
            .input-group {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        /* Photo upload styling */
        .photo-upload {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 1rem;
        }

        .photo-upload:hover {
            border-color: var(--primary);
            background: var(--surface-alt);
        }

        .photo-upload.has-image {
            border-style: solid;
            padding: 0;
        }

        .photo-preview {
            width: 100%;
            max-width: 200px;
            height: 150px;
            object-fit: cover;
            border-radius: var(--radius);
        }

        .thumbnail {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 6px;
            border: 2px solid var(--border);
            margin-right: 0.5rem;
        }

        /* Category styling */
        .category-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .category-option {
            padding: 0.5rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            touch-action: manipulation;
        }

        .category-option.selected {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }

        .category-option:hover {
            border-color: var(--primary);
        }

        /* Custom slider styling */
        .slider-group {
            background: var(--surface-alt);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .slider-container {
            margin-bottom: 1rem;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .slider-value {
            background: var(--primary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            min-width: 3rem;
            text-align: center;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--slider-track);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            transition: var(--transition);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(37, 99, 235, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            border: none;
            transition: var(--transition);
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(37, 99, 235, 0.5);
        }

        .add-property-btn {
            background: transparent;
            color: var(--primary);
            border: 2px dashed var(--primary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
            margin-top: 0.5rem;
        }

        .add-property-btn:hover {
            background: var(--primary);
            color: white;
        }

        /* Properties display */
        .properties-display {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--surface-alt);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .property-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border);
        }

        .property-item:last-child {
            border-bottom: none;
        }

        .property-name {
            font-weight: 600;
            font-size: 0.8rem;
        }

        .property-value {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .progress-bar {
            width: 60px;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 3px;
            transition: var(--transition);
        }

        .progress-fill.low {
            background: var(--error);
        }

        .progress-fill.medium {
            background: var(--warning);
        }

        .progress-fill.high {
            background: var(--success);
        }

        /* ID display styling */
        .id-badge {
            background: var(--primary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .category-badge {
            background: var(--success);
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 0.3rem;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.3rem;
        }

        /* Enhanced Inventory Tree with Dropdown */
        .inventory-tree {
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
        }

        .tree-item {
            margin-bottom: 0.25rem;
            position: relative;
        }

        .tree-node {
            padding: 0.75rem 0.5rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            min-height: 48px;
            flex-wrap: wrap;
            position: relative;
        }

        .tree-node:hover {
            background: var(--surface-alt);
            transform: translateX(2px);
        }

        .tree-node:active {
            background: var(--surface-alt);
            transform: scale(0.98);
        }

        .tree-node-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .tree-indent-0 {
            margin-left: 0;
            font-weight: 600;
            border-left: 3px solid var(--primary);
            padding-left: 1rem;
        }
        .tree-indent-1 {
            margin-left: 1rem;
            border-left: 2px solid var(--tree-line);
            padding-left: 1rem;
        }
        .tree-indent-2 {
            margin-left: 2rem;
            border-left: 1px solid var(--tree-line);
            padding-left: 1rem;
        }
        .tree-indent-3 {
            margin-left: 3rem;
            padding-left: 1rem;
        }

        /* Items dropdown container */
        .items-dropdown {
            margin-left: 2rem;
            padding: 0.5rem;
            background: var(--surface-alt);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            margin-top: 0.5rem;
            display: none;
        }

        .items-dropdown.active {
            display: block;
        }

        .item-entry {
            padding: 0.5rem;
            border-radius: var(--radius);
            margin-bottom: 0.5rem;
            background: var(--surface);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
        }

        .item-entry:hover {
            background: var(--primary);
            color: white;
        }

        .item-entry:last-child {
            margin-bottom: 0;
        }

        /* Room Canvas Editor Enhanced */
        .room-canvas-container {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .canvas-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .canvas-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
        }

        .canvas-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        #roomCanvas {
            border: 2px solid var(--border);
            border-radius: var(--radius);
            cursor: crosshair;
            background: var(--surface-alt);
            width: 100%;
            max-width: 600px;
            height: 400px;
            position: relative;
        }

        /* Rectangle editing handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }

        .resize-handle.nw { cursor: nw-resize; }
        .resize-handle.ne { cursor: ne-resize; }
        .resize-handle.sw { cursor: sw-resize; }
        .resize-handle.se { cursor: se-resize; }

        /* Microphone selector */
        .mic-selector {
            background: var(--surface-alt);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        /* Sync status indicator */
        .sync-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            font-size: 0.8rem;
            font-weight: 600;
        }

        .sync-indicator.online {
            background: var(--success);
            color: white;
        }

        .sync-indicator.offline {
            background: var(--error);
            color: white;
        }

        .sync-indicator.syncing {
            background: var(--warning);
            color: white;
            animation: pulse 1s infinite;
        }

        /* Filter section */
        .filter-section {
            background: var(--surface-alt);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .filter-btn {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-size: 0.8rem;
        }

        .filter-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* File input styling */
        .file-input-group {
            position: relative;
            margin-bottom: 1rem;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 0.75rem;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .file-input-label:hover {
            border-color: var(--primary);
            background: var(--surface-alt);
        }

        /* Settings modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.5rem;
            border-radius: 50%;
            transition: var(--transition);
        }

        .close-btn:hover {
            background: var(--surface-alt);
        }

        /* Statistics mobile-optimized */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: var(--surface);
            padding: 1rem 0.5rem;
            border-radius: var(--radius);
            text-align: center;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            box-shadow: var(--shadow);
            z-index: 1100;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-100%); }
            to { opacity: 1; transform: translateY(0); }
        }

        .notification.success { border-left: 4px solid var(--success); }
        .notification.error { border-left: 4px solid var(--error); }
        .notification.warning { border-left: 4px solid var(--warning); }

        /* Result highlight mobile-optimized */
        .result-highlight {
            background: linear-gradient(135deg, var(--success) 0%, #047857 100%);
            color: white;
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Theme toggle */
        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            border: none;
            background: var(--surface);
            box-shadow: var(--shadow);
            cursor: pointer;
            font-size: 1.2rem;
            transition: var(--transition);
            z-index: 100;
            touch-action: manipulation;
        }

        .theme-toggle:active {
            transform: scale(0.95);
        }

        /* Loading spinner */
        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Dark mode improvements */
        [data-theme="dark"] .mic-button {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .section {
            border-color: var(--border);
        }

        [data-theme="dark"] .modal {
            background: rgba(0, 0, 0, 0.8);
        }

        /* Item detail view */
        .item-detail {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1rem;
            margin: 0.5rem 0;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .item-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .item-name {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .edit-btn {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.3rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .edit-btn:hover {
            background: var(--primary);
            color: white;
        }

        .editable-slider {
            width: 100%;
            margin: 0.5rem 0;
        }

        .photo-section {
            text-align: center;
            margin-bottom: 1rem;
        }

        .large-photo {
            max-width: 100%;
            max-height: 300px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            overflow-x: auto;
        }

        .nav-tab {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            font-weight: 600;
        }

        .nav-tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">üåì</button>

    <div class="container">
        <div class="header">
            <h1>üè† Smart Inventar Organizer Pro</h1>
            <p>Vollst√§ndiges Inventar-Management mit Fotos, Grundriss und Sync</p>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalItems">0</div>
                <div class="stat-label">Gegenst√§nde</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalRooms">0</div>
                <div class="stat-label">R√§ume</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalContainers">0</div>
                <div class="stat-label">Container</div>
            </div>
        </div>

        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchTab('voice')">üé§ Sprache</div>
            <div class="nav-tab" onclick="switchTab('search')">üîç Suche</div>
            <div class="nav-tab" onclick="switchTab('add')">‚ûï Hinzuf√ºgen</div>
            <div class="nav-tab" onclick="switchTab('rooms')">üè† Grundriss</div>
            <div class="nav-tab" onclick="switchTab('inventory')">üì¶ Inventar</div>
            <div class="nav-tab" onclick="switchTab('settings')">‚öôÔ∏è Settings</div>
        </div>

        <!-- Voice Tab -->
        <div class="tab-content active" id="voice-tab">
            <div class="voice-section">
                <h3>üé§ Sprachsteuerung</h3>
                <button class="mic-button" id="micBtn">üé§</button>
                <div class="status" id="status">Bereit zum Lauschen</div>
                <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1rem;">
                    Sage "Hey Organizer" oder halte das Mikrofon gedr√ºckt
                </p>

                <!-- Microphone Selector -->
                <div class="mic-selector">
                    <h4>üéôÔ∏è Mikrofon ausw√§hlen:</h4>
                    <select id="microphoneSelect" class="input-field">
                        <option value="">Standard-Mikrofon</option>
                    </select>
                    <button class="btn btn-secondary" onclick="requestMicrophonePermission()">üîì Berechtigung anfordern</button>
                </div>

                <div class="quick-actions">
                    <button class="btn btn-secondary" onclick="testSpeech()">üîä Audio Test</button>
                    <button class="btn btn-secondary" onclick="switchTab('settings')">‚öôÔ∏è Einstellungen</button>
                </div>
            </div>
        </div>

        <!-- Search Tab -->
        <div class="tab-content" id="search-tab">
            <div class="section">
                <div class="section-header">
                    <span>üîç Erweiterte Suche</span>
                </div>
                <div class="section-content active">
                    <div class="search-container">
                        <input type="text" class="search-input" id="searchInput" placeholder="Suche nach Name, ID oder Eigenschaften...">
                    </div>
                    <div class="filter-section">
                        <h4 style="margin-bottom: 0.5rem;">üìã Nach Kategorie filtern:</h4>
                        <div class="filter-grid" id="categoryFilters"></div>
                        <h4 style="margin-bottom: 0.5rem;">‚ö° Schnellfilter:</h4>
                        <div class="filter-grid">
                            <button class="filter-btn" onclick="filterByProperty('f√ºllstand', 0, 20)">üî¥ Fast leer</button>
                            <button class="filter-btn" onclick="filterByProperty('f√ºllstand', 80, 100)">üü¢ Voll</button>
                            <button class="filter-btn" onclick="filterByProperty('zustand', 0, 30)">‚ö†Ô∏è Schlecht</button>
                            <button class="filter-btn" onclick="filterByProperty('batterie', 0, 25)">üîã Schwach</button>
                            <button class="filter-btn" onclick="clearFilters()">‚ùå Filter l√∂schen</button>
                        </div>
                    </div>
                    <div class="quick-actions">
                        <button class="btn" onclick="handleSearchInput()">Suchen</button>
                        <button class="btn btn-secondary" onclick="clearSearch()">Leeren</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Add Item Tab -->
        <div class="tab-content" id="add-tab">
            <div class="section">
                <div class="section-header">
                    <span>‚ûï Neuen Gegenstand hinzuf√ºgen</span>
                </div>
                <div class="section-content active">
                    <!-- Photo Upload -->
                    <div class="photo-upload" onclick="document.getElementById('photoInput').click()" id="photoUploadArea">
                        <input type="file" id="photoInput" accept="image/*" style="display: none;" onchange="handlePhotoUpload(this)">
                        <p>üì∑ Foto hinzuf√ºgen<br><small>Klicken zum Ausw√§hlen</small></p>
                    </div>

                    <div class="input-group">
                        <div class="form-group">
                            <label for="newItem">Gegenstand*</label>
                            <input type="text" class="input-field" id="newItem" placeholder="z.B. F√∂hn, Laptop, Hammer">
                        </div>
                        <div class="form-group">
                            <label for="newRoom">Raum*</label>
                            <input type="text" class="input-field" id="newRoom" placeholder="z.B. B√ºro, K√ºche, Garage">
                        </div>
                        <div class="form-group">
                            <label for="newFurniture">M√∂bel (optional)</label>
                            <input type="text" class="input-field" id="newFurniture" placeholder="z.B. Schreibtisch, Regal">
                        </div>
                        <div class="form-group">
                            <label for="newContainer">Container (optional)</label>
                            <input type="text" class="input-field" id="newContainer" placeholder="z.B. Schublade, Kiste">
                        </div>
                    </div>

                    <!-- Category Selection -->
                    <div class="form-group">
                        <label>üè∑Ô∏è Kategorie</label>
                        <div class="category-selector" id="categorySelector"></div>
                    </div>

                    <!-- Properties Section -->
                    <div class="slider-group">
                        <h4 style="margin-bottom: 1rem;">üìä Eigenschaften (0-100)</h4>
                        <div id="propertySliders"></div>
                        <button class="add-property-btn" onclick="addCustomProperty()">‚ûï Eigene Eigenschaft hinzuf√ºgen</button>
                    </div>

                    <div class="quick-actions">
                        <button class="btn" onclick="addItem()">Hinzuf√ºgen</button>
                        <button class="btn btn-secondary" onclick="clearForm()">Leeren</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Room Layout Tab -->
        <div class="tab-content" id="rooms-tab">
            <div class="room-canvas-container">
                <h3>üè† Grundriss Editor</h3>
                <div class="canvas-controls">
                    <button class="canvas-btn active" onclick="setCanvasMode('draw')" id="drawBtn">‚úèÔ∏è Zeichnen</button>
                    <button class="canvas-btn" onclick="setCanvasMode('rectangle')" id="rectangleBtn">‚ñ≠ Rechteck</button>
                    <button class="canvas-btn" onclick="setCanvasMode('item')" id="itemBtn">üì¶ Gegenstand</button>
                    <button class="canvas-btn" onclick="clearCanvas()">üóëÔ∏è L√∂schen</button>
                    <select id="roomSelector" class="input-field" style="max-width: 200px;">
                        <option value="">Raum ausw√§hlen</option>
                    </select>
                </div>
                <canvas id="roomCanvas" width="600" height="400"></canvas>
                <p style="margin-top: 1rem; color: var(--text-muted); font-size: 0.9rem;">
                    Zeichne frei, erstelle Rechtecke (anklicken zum Bearbeiten), platziere Gegenst√§nde
                </p>
            </div>
        </div>

        <!-- Inventory Tab -->
        <div class="tab-content" id="inventory-tab">
            <div class="section">
                <div class="section-header">
                    <span>üì¶ Inventar √úbersicht</span>
                </div>
                <div class="section-content active">
                    <div style="margin-bottom: 1rem;">
                        <button class="btn btn-secondary" onclick="toggleExpandAll()">Alle √∂ffnen/schlie√üen</button>
                        <button class="btn btn-secondary" onclick="exportData()">üíæ Export</button>
                    </div>
                    <div class="inventory-tree" id="inventoryTree"></div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settings-tab">
            <div class="section">
                <div class="section-header" onclick="toggleSection('audio-settings')">
                    <span>üéµ Audio-Einstellungen</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="section-content active" id="audio-settings-content">
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="continuousListening"> Kontinuierliches Zuh√∂ren
                        </label>
                        <small style="color: var(--text-muted);">Wake Word Detection aktivieren</small>
                    </div>
                    <div class="form-group">
                        <label for="speechRate">Sprechgeschwindigkeit</label>
                        <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="0.9" class="slider">
                    </div>
                    <div class="form-group">
                        <label for="speechVolume">Lautst√§rke</label>
                        <input type="range" id="speechVolume" min="0" max="1" step="0.1" value="1" class="slider">
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" onclick="toggleSection('sync-settings')">
                    <span>üîÑ Netzwerk-Synchronisation</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="section-content" id="sync-settings-content">
                    <div class="sync-indicator offline" id="syncStatus">
                        üî¥ Offline
                    </div>
                    <div class="form-group">
                        <button class="btn" onclick="startSyncServer()">üì° Sync-Server starten</button>
                        <button class="btn btn-secondary" onclick="searchForSyncDevices()">üîç Ger√§te suchen</button>
                    </div>
                    <div class="form-group">
                        <label>Verf√ºgbare Ger√§te:</label>
                        <div id="availableDevices">Keine Ger√§te gefunden</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" onclick="toggleSection('import-export')">
                    <span>üíæ Import & Export</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="section-content" id="import-export-content">
                    <div class="form-group">
                        <label>üì• Daten importieren:</label>
                        <div class="file-input-group">
                            <input type="file" id="importFile" accept=".json" class="file-input" onchange="importData()">
                            <label for="importFile" class="file-input-label">
                                üìÅ JSON-Datei ausw√§hlen
                            </label>
                        </div>
                        <small style="color: var(--text-muted);">Backup-Datei im JSON-Format importieren</small>
                    </div>
                    <div class="form-group">
                        <label>üì§ Daten exportieren:</label>
                        <button class="btn" onclick="exportData()">üíæ Vollst√§ndigen Export herunterladen</button>
                        <small style="color: var(--text-muted); display: block; margin-top: 0.5rem;">
                            Exportiert alle Daten inklusive Fotos und Grundrisse
                        </small>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" onclick="toggleSection('properties-settings')">
                    <span>üìä Eigenschaften verwalten</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="section-content" id="properties-settings-content">
                    <div class="form-group">
                        <label>üè∑Ô∏è Standard-Kategorien bearbeiten:</label>
                        <textarea id="categoriesEdit" class="input-field" rows="8" placeholder="Eine Kategorie pro Zeile"></textarea>
                        <button class="btn btn-secondary" onclick="updateCategories()">Kategorien speichern</button>
                    </div>
                    <div class="form-group">
                        <label>üìä Standard-Eigenschaften bearbeiten:</label>
                        <textarea id="propertiesEdit" class="input-field" rows="5" placeholder="Eine Eigenschaft pro Zeile"></textarea>
                        <button class="btn btn-secondary" onclick="updateProperties()">Eigenschaften speichern</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" onclick="toggleSection('app-settings')">
                    <span>üì± App-Einstellungen</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="section-content" id="app-settings-content">
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="showIds"> IDs in der Anzeige zeigen
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="autoSave"> Automatisch speichern
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="autoExport"> Auto-Export beim Schlie√üen
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="language">Sprache</label>
                        <select class="input-field" id="language">
                            <option value="de-DE">Deutsch</option>
                            <option value="en-US">English</option>
                            <option value="fr-FR">Fran√ßais</option>
                            <option value="es-ES">Espa√±ol</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button class="btn btn-secondary" onclick="resetApp()">üóëÔ∏è Alle Daten l√∂schen</button>
                    </div>
                </div>
            </div>

            <div style="margin-top: 1.5rem; text-align: center;">
                <button class="btn" onclick="saveSettings()">Einstellungen speichern</button>
            </div>
        </div>
    </div>

    <!-- Item Detail Modal -->
    <div class="modal" id="itemDetailModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="itemDetailTitle">üìã Gegenstand Details</h3>
                <button class="close-btn" onclick="closeItemDetail()">√ó</button>
            </div>
            <div id="itemDetailContent"></div>
        </div>
    </div>

    <script>
        // ==================== CORE DATA MANAGEMENT ====================
        const STORAGE_KEY = 'smart_inventory';
        const SETTINGS_KEY = 'inventory_settings';
        let inventory = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
        let expandedNodes = new Set();
        let expandedItems = new Set(); // For item dropdowns
        let allExpanded = false;
        let idCounter = parseInt(localStorage.getItem('id_counter') || '1000');
        let currentFilters = {};
        let roomLayouts = JSON.parse(localStorage.getItem('room_layouts') || '{}');

        // Extended categories including fishing and specialized categories
        const DEFAULT_CATEGORIES = [
            'üì± Elektronik', 'üîß Werkzeug', 'üëï Kleidung', 'üìö B√ºcher',
            'üç≥ K√ºche', 'üéÆ Spiele', 'üíÑ Kosmetik', 'üßΩ Reinigung',
            'üè† Haushalt', 'üöó Auto', 'üíä Medizin', 'üé® Hobby',
            'üé£ Angeln', 'ü™ù Angeln_kleinkram', 'üö¢ Hochsee', 'üéØ Rutenbau',
            'üö¥ Einrad', 'üé™ Event', 'üî© Ersatzteile', '‚ö° Microelektronik',
            'üè¢ B√ºro', '‚õ∫ Camping', 'üêï Hund', 'üé® Kunst',
            'üëü Sportkleidung', 'üå± Pflanzen', 'üê† Aquarium'
        ];

        const DEFAULT_PROPERTIES = [
            'F√ºllstand', 'Zustand', 'Batterie', 'Qualit√§t', 'Sauberkeit'
        ];

        // Settings with all new features
        let settings = {
            continuousListening: true,
            speechRate: 0.9,
            speechVolume: 1.0,
            showIds: false,
            autoSave: true,
            autoExport: true,
            language: 'de-DE',
            speechApiKey: '',
            speechApiProvider: 'browser',
            debugMode: false,
            categories: DEFAULT_CATEGORIES,
            properties: DEFAULT_PROPERTIES,
            selectedMicrophone: '',
            ...JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}')
        };

        // Current form state
        let currentProperties = {};
        let selectedCategory = '';
        let currentPhoto = null;
        let currentEditingItem = null;

        // Enhanced Canvas state
        let canvas, ctx;
        let canvasMode = 'draw';
        let isDrawing = false;
        let currentRoom = '';
        let rectangles = []; // Store rectangles for editing
        let selectedRectangle = null;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let startX, startY;

        // Sync state
        let syncConnection = null;
        let syncServer = null;

        // ID Generation
        function generateId(prefix = 'ITM') {
            const id = `${prefix}-${String(idCounter).padStart(4, '0')}`;
            idCounter++;
            localStorage.setItem('id_counter', idCounter.toString());
            return id;
        }

        function saveData() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(inventory, null, 2));
            localStorage.setItem('room_layouts', JSON.stringify(roomLayouts, null, 2));

            if (settings.autoSave) {
                updateStats();
                renderInventory();
                updateCategoryFilters();
                updateRoomSelector();
            }

            if (settings.autoExport) {
                autoExportData();
            }
        }

        function saveSettings() {
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings, null, 2));
            showNotification('Einstellungen gespeichert!', 'success');
            applySettings();
        }

        function applySettings() {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }

            updateUI();
            setupCategorySelector();
            setupPropertySliders();

            if (settings.continuousListening && speechSupported) {
                startWakeWordListening();
            } else if (wakeWordRecognition) {
                wakeWordRecognition.stop();
            }
        }

        // ==================== TAB NAVIGATION ====================
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`${tabName}-tab`).classList.add('active');
            event.target.classList.add('active');

            // Initialize specific tab features
            if (tabName === 'rooms') {
                initRoomCanvas();
            }
        }

        // ==================== ENHANCED SPEECH RECOGNITION ====================
        let recognition = null;
        let wakeWordRecognition = null;
        let isListening = false;
        let speechSupported = false;
        let mediaStream = null;
        let availableMicrophones = [];

        async function requestMicrophonePermission() {
            try {
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }

                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: settings.selectedMicrophone ? { exact: settings.selectedMicrophone } : undefined,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                showNotification('Mikrofon-Berechtigung erteilt!', 'success');
                await updateMicrophoneList();

                // Stop stream after permission check
                mediaStream.getTracks().forEach(track => track.stop());

            } catch (error) {
                console.error('Microphone permission error:', error);
                showNotification('Mikrofon-Zugriff verweigert. Bitte in den Browser-Einstellungen erlauben.', 'error');
            }
        }

        async function updateMicrophoneList() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableMicrophones = devices.filter(device => device.kind === 'audioinput');

                const select = document.getElementById('microphoneSelect');
                select.innerHTML = '<option value="">Standard-Mikrofon</option>';

                availableMicrophones.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Mikrofon ${availableMicrophones.indexOf(device) + 1}`;
                    if (device.deviceId === settings.selectedMicrophone) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                select.onchange = () => {
                    settings.selectedMicrophone = select.value;
                    saveSettings();
                };

            } catch (error) {
                console.error('Error listing microphones:', error);
            }
        }

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                log('Speech Recognition not supported - using fallback methods');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            speechSupported = true;

            // Request microphone permission on init
            requestMicrophonePermission();

            if (settings.continuousListening) {
                startWakeWordListening();
            }

            return true;
        }

        function startWakeWordListening() {
            if (!speechSupported || !settings.continuousListening) return;

            if (wakeWordRecognition) {
                wakeWordRecognition.stop();
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = false;
            wakeWordRecognition.lang = settings.language;

            wakeWordRecognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
                log(`Wake word detection: ${transcript}`);

                if (transcript.includes('hey organizer') ||
                    transcript.includes('organizer') ||
                    transcript.includes('hey inventory')) {
                    speak('Ja, ich h√∂re! Was suchst du?');
                    startActiveListening();
                }
            };

            wakeWordRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && settings.debugMode) {
                    log(`Wake word error: ${event.error}`);
                }

                if (event.error !== 'not-allowed') {
                    setTimeout(() => {
                        if (settings.continuousListening) {
                            startWakeWordListening();
                        }
                    }, 1000);
                }
            };

            wakeWordRecognition.onend = () => {
                if (settings.continuousListening) {
                    setTimeout(startWakeWordListening, 500);
                }
            };

            try {
                wakeWordRecognition.start();
                log('Wake word listening started');
            } catch (e) {
                log(`Could not start wake word recognition: ${e.message}`);
            }
        }

        function startActiveListening() {
            if (!speechSupported) {
                showNotification('Spracherkennung nicht verf√ºgbar', 'error');
                return;
            }

            if (recognition) {
                recognition.stop();
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = settings.language;
            recognition.maxAlternatives = 3;

            setStatus('listening', 'Ich h√∂re zu...');
            isListening = true;

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript.trim();
                log(`Heard: ${transcript}`);
                setStatus('processing', 'Verarbeite...');
                handleVoiceInput(transcript);
            };

            recognition.onend = () => {
                setStatus('idle', 'Bereit zum Lauschen');
                isListening = false;
            };

            recognition.onerror = (event) => {
                setStatus('idle', 'Bereit zum Lauschen');
                isListening = false;

                if (event.error === 'not-allowed') {
                    showNotification('Mikrofon-Zugriff verweigert. Bitte Berechtigung erteilen.', 'error');
                } else if (event.error === 'no-speech') {
                    showNotification('Nichts geh√∂rt. Versuche es nochmal.', 'warning');
                } else if (settings.debugMode) {
                    showNotification(`Fehler: ${event.error}`, 'error');
                }
            };

            try {
                recognition.start();
            } catch (e) {
                setStatus('idle', 'Bereit zum Lauschen');
                isListening = false;
                showNotification('Konnte Spracherkennung nicht starten', 'error');
            }
        }

        // ==================== ENHANCED TEXT TO SPEECH ====================
        function speak(text) {
            if (!('speechSynthesis' in window)) {
                showNotification(text, 'info');
                return;
            }

            setStatus('speaking', 'Spreche...');
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = settings.language;
            utterance.rate = settings.speechRate;
            utterance.volume = settings.speechVolume;
            utterance.pitch = 1;

            utterance.onend = () => {
                setStatus('idle', 'Bereit zum Lauschen');
            };

            utterance.onerror = (event) => {
                setStatus('idle', 'Bereit zum Lauschen');
                if (settings.debugMode) {
                    log(`Speech error: ${event.error}`);
                }
            };

            const voices = window.speechSynthesis.getVoices();
            const germanVoice = voices.find(voice => voice.lang.startsWith(settings.language.split('-')[0]));
            if (germanVoice) {
                utterance.voice = germanVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function testSpeech() {
            speak('Audio-Test erfolgreich! Mikrofon und Lautsprecher funktionieren.');
        }

        // ==================== PHOTO HANDLING ====================
        function handlePhotoUpload(input) {
            const file = input.files[0];
            if (!file) return;

            if (file.size > 5 * 1024 * 1024) {
                showNotification('Foto zu gro√ü! Maximal 5MB erlaubt.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                currentPhoto = e.target.result;
                displayPhotoPreview(currentPhoto);
            };
            reader.readAsDataURL(file);
        }

        function displayPhotoPreview(photoData) {
            const uploadArea = document.getElementById('photoUploadArea');
            uploadArea.innerHTML = `
                <img src="${photoData}" class="photo-preview" alt="Vorschau">
                <p style="margin-top: 0.5rem;">‚úÖ Foto ausgew√§hlt</p>
            `;
            uploadArea.classList.add('has-image');
        }

        function resetPhotoUpload() {
            const uploadArea = document.getElementById('photoUploadArea');
            uploadArea.innerHTML = `
                <input type="file" id="photoInput" accept="image/*" style="display: none;" onchange="handlePhotoUpload(this)">
                <p>üì∑ Foto hinzuf√ºgen<br><small>Klicken zum Ausw√§hlen</small></p>
            `;
            uploadArea.classList.remove('has-image');
            uploadArea.onclick = () => document.getElementById('photoInput').click();
            currentPhoto = null;
        }

        // ==================== ENHANCED INPUT HANDLING ====================
        function handleVoiceInput(input) {
            const lowerInput = input.toLowerCase();

            // Check for category searches
            if (lowerInput.includes('zeige') || lowerInput.includes('finde')) {
                const categoryMatch = settings.categories.find(cat =>
                    lowerInput.includes(cat.toLowerCase().replace(/üì±|üîß|üëï|üìö|üç≥|üéÆ|üíÑ|üßΩ|üè†|üöó|üíä|üé®|üé£|ü™ù|üö¢|üéØ|üö¥|üé™|üî©|‚ö°|üè¢|‚õ∫|üêï|üé®|üëü|üå±|üê†/g, '').trim())
                );

                if (categoryMatch) {
                    filterByCategory(categoryMatch);
                    speak(`Zeige alle Gegenst√§nde der Kategorie ${categoryMatch}`);
                    switchTab('inventory');
                    return;
                }
            }

            // Check for property-based searches
            if (lowerInput.includes('leer') || lowerInput.includes('wenig')) {
                filterByProperty('f√ºllstand', 0, 20);
                speak('Zeige alle fast leeren Gegenst√§nde');
                switchTab('inventory');
                return;
            }

            if (lowerInput.includes('voll')) {
                filterByProperty('f√ºllstand', 80, 100);
                speak('Zeige alle vollen Gegenst√§nde');
                switchTab('inventory');
                return;
            }

            // Regular item search
            const result = searchItem(input);
            if (result.found) {
                const pathText = result.path.join(' in ');
                let response = `${result.item} findest du in ${pathText}`;

                if (result.properties && Object.keys(result.properties).length > 0) {
                    const propertyInfo = Object.entries(result.properties)
                        .map(([key, value]) => `${key}: ${value}%`)
                        .join(', ');
                    response += `. Eigenschaften: ${propertyInfo}`;
                }

                speak(response);
                highlightResult(result);
                showItemDetail(result);
            } else {
                const suggestions = getSuggestions(input);
                if (suggestions.length > 0) {
                    speak(`Ich habe ${input} nicht gefunden. Meintest du vielleicht ${suggestions[0].name}?`);
                } else {
                    speak(`${input} ist nicht in deinem Inventar. M√∂chtest du es hinzuf√ºgen?`);
                }
            }
        }

        function handleSearchInput() {
            const input = document.getElementById('searchInput').value.trim();
            if (!input) return;

            const result = searchItem(input);
            if (result.found) {
                highlightResult(result);
                showItemDetail(result);
                const message = settings.showIds ?
                    `${result.item} (ID: ${result.id}) gefunden in: ${result.path.join(' ‚Üí ')}` :
                    `${result.item} gefunden in: ${result.path.join(' ‚Üí ')}`;
                showNotification(message, 'success');
                speak(`Gefunden! ${result.item} ist in ${result.path.join(' in ')}`);
                switchTab('inventory');
            } else {
                showNotification(`${input} nicht gefunden`, 'error');
                speak(`${input} nicht gefunden`);
            }
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            clearFilters();
        }

        // ==================== ENHANCED SEARCH WITH PROPERTIES ====================
        function searchItem(query) {
            const normalizedQuery = query.toLowerCase().trim();

            function searchInObject(obj, path = []) {
                for (const [key, value] of Object.entries(obj)) {
                    const currentPath = [...path, key];

                    if (Array.isArray(value)) {
                        for (const item of value) {
                            if (typeof item === 'object') {
                                // Search in name, ID, category, and properties
                                if (item.name.toLowerCase().includes(normalizedQuery) ||
                                    item.id.toLowerCase().includes(normalizedQuery) ||
                                    (item.category && item.category.toLowerCase().includes(normalizedQuery))) {
                                    return {
                                        found: true,
                                        item: item.name,
                                        id: item.id,
                                        category: item.category,
                                        properties: item.properties || {},
                                        photo: item.photo,
                                        path: currentPath
                                    };
                                }

                                // Search in properties
                                if (item.properties) {
                                    for (const [propKey, propValue] of Object.entries(item.properties)) {
                                        if (propKey.toLowerCase().includes(normalizedQuery)) {
                                            return {
                                                found: true,
                                                item: item.name,
                                                id: item.id,
                                                category: item.category,
                                                properties: item.properties,
                                                photo: item.photo,
                                                path: currentPath
                                            };
                                        }
                                    }
                                }
                            } else {
                                // Legacy structure
                                if (item.toLowerCase().includes(normalizedQuery)) {
                                    return {
                                        found: true,
                                        item: item,
                                        id: 'Legacy',
                                        path: currentPath
                                    };
                                }
                            }
                        }
                    } else if (typeof value === 'object') {
                        const result = searchInObject(value, currentPath);
                        if (result.found) return result;
                    }

                    if (key.toLowerCase().includes(normalizedQuery)) {
                        return {
                            found: true,
                            item: key,
                            id: 'Container',
                            path: path.length > 0 ? path : ['Bereich']
                        };
                    }
                }
                return { found: false };
            }

            return searchInObject(inventory);
        }

        // ==================== PROPERTY SYSTEM ====================
        function setupPropertySliders() {
            const container = document.getElementById('propertySliders');
            container.innerHTML = '';

            settings.properties.forEach(property => {
                createPropertySlider(property.toLowerCase(), container);
            });
        }

        function createPropertySlider(property, container) {
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';

            const value = currentProperties[property] || 50;

            sliderContainer.innerHTML = `
                <div class="slider-label">
                    <span>${property.charAt(0).toUpperCase() + property.slice(1)}</span>
                    <span class="slider-value" id="${property}Value">${value}%</span>
                </div>
                <input type="range" class="slider" id="${property}Slider"
                       min="0" max="100" value="${value}"
                       oninput="updateSliderValue('${property}', this.value)">
            `;

            container.appendChild(sliderContainer);
            currentProperties[property] = value;
        }

        function updateSliderValue(property, value) {
            document.getElementById(`${property}Value`).textContent = `${value}%`;
            currentProperties[property] = parseInt(value);
        }

        function addCustomProperty() {
            const propertyName = prompt('Name der neuen Eigenschaft:');
            if (propertyName && propertyName.trim()) {
                const normalizedName = propertyName.toLowerCase().trim();
                if (!settings.properties.includes(normalizedName)) {
                    settings.properties.push(normalizedName);
                    createPropertySlider(normalizedName, document.getElementById('propertySliders'));
                    saveSettings();
                }
            }
        }

        function setupCategorySelector() {
            const container = document.getElementById('categorySelector');
            container.innerHTML = '';

            settings.categories.forEach(category => {
                const option = document.createElement('div');
                option.className = 'category-option';
                option.textContent = category;
                option.onclick = () => selectCategory(category, option);
                container.appendChild(option);
            });
        }

        function selectCategory(category, element) {
            // Remove previous selection
            document.querySelectorAll('.category-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Add selection to clicked element
            element.classList.add('selected');
            selectedCategory = category;
        }

        // ==================== FILTERING SYSTEM ====================
        function updateCategoryFilters() {
            const container = document.getElementById('categoryFilters');
            if (!container) return;

            container.innerHTML = '';

            // Get all unique categories from inventory
            const categories = new Set();

            function collectCategories(obj) {
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        value.forEach(item => {
                            if (typeof item === 'object' && item.category) {
                                categories.add(item.category);
                            }
                        });
                    } else if (typeof value === 'object') {
                        collectCategories(value);
                    }
                }
            }

            collectCategories(inventory);

            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.textContent = category;
                btn.onclick = () => filterByCategory(category);
                container.appendChild(btn);
            });
        }

        function filterByCategory(category) {
            currentFilters.category = category;
            renderFilteredInventory();
            showNotification(`Filter: ${category}`, 'info');
        }

        function filterByProperty(property, min, max) {
            currentFilters.property = { name: property, min, max };
            renderFilteredInventory();
            showNotification(`Filter: ${property} zwischen ${min}% und ${max}%`, 'info');
        }

        function clearFilters() {
            currentFilters = {};
            renderInventory();
            showNotification('Filter gel√∂scht', 'info');
        }

        function renderFilteredInventory() {
            const tree = document.getElementById('inventoryTree');
            tree.innerHTML = '';

            const filteredItems = [];

            function collectFilteredItems(obj, path = []) {
                for (const [key, value] of Object.entries(obj)) {
                    const currentPath = [...path, key];

                    if (Array.isArray(value)) {
                        value.forEach(item => {
                            if (typeof item === 'object') {
                                let matches = true;

                                // Category filter
                                if (currentFilters.category && item.category !== currentFilters.category) {
                                    matches = false;
                                }

                                // Property filter
                                if (currentFilters.property && item.properties) {
                                    const propValue = item.properties[currentFilters.property.name];
                                    if (propValue === undefined ||
                                        propValue < currentFilters.property.min ||
                                        propValue > currentFilters.property.max) {
                                        matches = false;
                                    }
                                }

                                if (matches) {
                                    filteredItems.push({
                                        ...item,
                                        path: currentPath
                                    });
                                }
                            }
                        });
                    } else if (typeof value === 'object') {
                        collectFilteredItems(value, currentPath);
                    }
                }
            }

            collectFilteredItems(inventory);

            if (filteredItems.length === 0) {
                tree.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 2rem;">Keine Gegenst√§nde entsprechen den Filtern</p>';
                return;
            }

            filteredItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'tree-item';

                const itemNode = document.createElement('div');
                itemNode.className = 'tree-node tree-indent-0';
                itemNode.onclick = () => showItemDetail(item);

                const idDisplay = settings.showIds ? `<span class="id-badge">${item.id}</span>` : '';
                const categoryDisplay = item.category ? `<span class="category-badge">${item.category}</span>` : '';
                const photoThumbnail = item.photo ? `<img src="${item.photo}" class="thumbnail" alt="Foto">` : '';

                itemNode.innerHTML = `
                    <div class="tree-node-content">
                        ${photoThumbnail}
                        <span>üìã ${item.name}${idDisplay}${categoryDisplay}</span>
                        <small style="color: var(--text-muted);">${item.path.join(' ‚Üí ')}</small>
                    </div>
                `;

                if (item.properties && Object.keys(item.properties).length > 0) {
                    const propertiesDiv = document.createElement('div');
                    propertiesDiv.className = 'properties-display';

                    Object.entries(item.properties).forEach(([key, value]) => {
                        const propertyDiv = document.createElement('div');
                        propertyDiv.className = 'property-item';

                        let fillClass = 'medium';
                        if (value <= 25) fillClass = 'low';
                        else if (value >= 75) fillClass = 'high';

                        propertyDiv.innerHTML = `
                            <span class="property-name">${key}</span>
                            <div class="property-value">
                                <div class="progress-bar">
                                    <div class="progress-fill ${fillClass}" style="width: ${value}%"></div>
                                </div>
                                <span style="font-size: 0.7rem;">${value}%</span>
                            </div>
                        `;

                        propertiesDiv.appendChild(propertyDiv);
                    });

                    itemNode.appendChild(propertiesDiv);
                }

                itemDiv.appendChild(itemNode);
                tree.appendChild(itemDiv);
            });
        }

        // ==================== ITEM MANAGEMENT ====================
        function addItem() {
            const itemName = document.getElementById('newItem').value.trim();
            const room = document.getElementById('newRoom').value.trim();
            const furniture = document.getElementById('newFurniture').value.trim();
            const container = document.getElementById('newContainer').value.trim();

            if (!itemName || !room) {
                showNotification('Gegenstand und Raum sind erforderlich!', 'error');
                return;
            }

            // Create item with ID, category, properties, and photo
            const item = {
                name: itemName,
                id: generateId('ITM'),
                category: selectedCategory,
                properties: {...currentProperties},
                photo: currentPhoto,
                addedAt: new Date().toISOString()
            };

            // Flexible hierarchy
            let target = inventory;

            if (!target[room]) {
                target[room] = {
                    _meta: {
                        id: generateId('ROM'),
                        type: 'room',
                        createdAt: new Date().toISOString()
                    }
                };
            }
            target = target[room];

            if (furniture) {
                if (!target[furniture]) {
                    target[furniture] = {
                        _meta: {
                            id: generateId('FUR'),
                            type: 'furniture',
                            createdAt: new Date().toISOString()
                        }
                    };
                }
                target = target[furniture];
            }

            if (container) {
                if (!target[container]) {
                    target[container] = [];
                    target[`${container}_meta`] = {
                        id: generateId('CON'),
                        type: 'container',
                        createdAt: new Date().toISOString()
                    };
                }
                target[container].push(item);
            } else {
                if (!target._items) target._items = [];
                target._items.push(item);
            }

            saveData();
            clearForm();

            const message = settings.showIds ?
                `${itemName} (ID: ${item.id}) wurde hinzugef√ºgt!` :
                `${itemName} wurde hinzugef√ºgt!`;
            showNotification(message, 'success');
            speak(`${itemName} wurde erfolgreich hinzugef√ºgt`);
        }

        function clearForm() {
            ['newItem', 'newRoom', 'newFurniture', 'newContainer'].forEach(id => {
                document.getElementById(id).value = '';
            });

            // Reset category selection
            document.querySelectorAll('.category-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            selectedCategory = '';

            // Reset properties
            currentProperties = {};
            setupPropertySliders();

            // Reset photo
            resetPhotoUpload();
        }

        // ==================== ENHANCED ITEM DETAIL VIEW ====================
        function showItemDetail(item) {
            const modal = document.getElementById('itemDetailModal');
            const title = document.getElementById('itemDetailTitle');
            const content = document.getElementById('itemDetailContent');

            title.textContent = `üìã ${item.name}`;
            currentEditingItem = item;

            let detailHTML = `
                <div class="item-detail">
                    <div class="item-detail-header">
                        <span class="item-name">${item.name}</span>
                        <button class="edit-btn" onclick="toggleEditMode()">‚úèÔ∏è Bearbeiten</button>
                    </div>
            `;

            // Photo section
            if (item.photo) {
                detailHTML += `
                    <div class="photo-section">
                        <img src="${item.photo}" class="large-photo" alt="${item.name}">
                    </div>
                `;
            }

            if (settings.showIds) {
                detailHTML += `<p><strong>ID:</strong> ${item.id}</p>`;
            }

            if (item.category) {
                detailHTML += `<p><strong>Kategorie:</strong> ${item.category}</p>`;
            }

            if (item.path) {
                detailHTML += `<p><strong>Standort:</strong> ${item.path.join(' ‚Üí ')}</p>`;
            }

            if (item.properties && Object.keys(item.properties).length > 0) {
                detailHTML += `<h4 style="margin-top: 1rem;">üìä Eigenschaften:</h4>`;
                detailHTML += `<div class="properties-display" id="editableProperties">`;

                Object.entries(item.properties).forEach(([key, value]) => {
                    let fillClass = 'medium';
                    if (value <= 25) fillClass = 'low';
                    else if (value >= 75) fillClass = 'high';

                    detailHTML += `
                        <div class="property-item">
                            <span class="property-name">${key.charAt(0).toUpperCase() + key.slice(1)}</span>
                            <div class="property-value">
                                <div class="progress-bar">
                                    <div class="progress-fill ${fillClass}" style="width: ${value}%"></div>
                                </div>
                                <span id="${key}ValueDisplay">${value}%</span>
                                <input type="range" class="editable-slider" id="${key}EditSlider"
                                       min="0" max="100" value="${value}"
                                       oninput="updateEditableProperty('${key}', this.value)"
                                       style="display: none;">
                            </div>
                        </div>
                    `;
                });

                detailHTML += `</div>`;
                detailHTML += `<button class="btn" onclick="savePropertyChanges()" id="savePropertiesBtn" style="display: none; margin-top: 1rem;">üíæ √Ñnderungen speichern</button>`;
            }

            if (item.addedAt) {
                const date = new Date(item.addedAt).toLocaleDateString('de-DE');
                detailHTML += `<p style="margin-top: 1rem; color: var(--text-muted); font-size: 0.8rem;"><strong>Hinzugef√ºgt:</strong> ${date}</p>`;
            }

            detailHTML += `</div>`;

            content.innerHTML = detailHTML;
            modal.classList.add('active');
        }

        function toggleEditMode() {
            const editBtn = document.querySelector('.edit-btn');
            const sliders = document.querySelectorAll('.editable-slider');
            const saveBtn = document.getElementById('savePropertiesBtn');

            if (editBtn.textContent.includes('Bearbeiten')) {
                editBtn.textContent = '‚ùå Abbrechen';
                sliders.forEach(slider => slider.style.display = 'block');
                if (saveBtn) saveBtn.style.display = 'block';
            } else {
                editBtn.textContent = '‚úèÔ∏è Bearbeiten';
                sliders.forEach(slider => slider.style.display = 'none');
                if (saveBtn) saveBtn.style.display = 'none';
            }
        }

        function updateEditableProperty(property, value) {
            const valueDisplay = document.getElementById(`${property}ValueDisplay`);
            if (valueDisplay) {
                valueDisplay.textContent = `${value}%`;
            }

            // Update progress bar
            const propertyItem = document.querySelector(`#editableProperties .property-item:has(#${property}EditSlider)`);
            if (propertyItem) {
                const progressFill = propertyItem.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = `${value}%`;

                    // Update color class
                    let fillClass = 'medium';
                    if (value <= 25) fillClass = 'low';
                    else if (value >= 75) fillClass = 'high';

                    progressFill.className = `progress-fill ${fillClass}`;
                }
            }
        }

        function savePropertyChanges() {
            if (!currentEditingItem) return;

            // Update properties from sliders
            const sliders = document.querySelectorAll('.editable-slider');
            sliders.forEach(slider => {
                const property = slider.id.replace('EditSlider', '');
                const value = parseInt(slider.value);
                currentEditingItem.properties[property] = value;
            });

            // Update in inventory
            updateItemInInventory(currentEditingItem);

            saveData();
            showNotification('Eigenschaften gespeichert!', 'success');
            toggleEditMode();
        }

        function updateItemInInventory(updatedItem) {
            function searchAndUpdate(obj) {
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        for (let i = 0; i < value.length; i++) {
                            if (typeof value[i] === 'object' && value[i].id === updatedItem.id) {
                                value[i] = updatedItem;
                                return true;
                            }
                        }
                    } else if (typeof value === 'object') {
                        if (searchAndUpdate(value)) return true;
                    }
                }
                return false;
            }

            searchAndUpdate(inventory);
        }

        function closeItemDetail() {
            document.getElementById('itemDetailModal').classList.remove('active');
            currentEditingItem = null;
        }

        // ==================== ENHANCED ROOM CANVAS EDITOR ====================
        function initRoomCanvas() {
            canvas = document.getElementById('roomCanvas');
            ctx = canvas.getContext('2d');

            updateRoomSelector();

            // Remove existing event listeners
            canvas.removeEventListener('mousedown', handleCanvasMouseDown);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('mouseup', handleCanvasMouseUp);
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('touchstart', handleTouch);
            canvas.removeEventListener('touchmove', handleTouch);
            canvas.removeEventListener('touchend', handleTouch);

            // Add event listeners
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('click', handleCanvasClick);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', handleTouch);

            // Load room data
            loadRoomData();
            redrawCanvas();
        }

        function updateRoomSelector() {
            const selector = document.getElementById('roomSelector');
            if (!selector) return;

            selector.innerHTML = '<option value="">Raum ausw√§hlen</option>';

            Object.keys(inventory).forEach(room => {
                const option = document.createElement('option');
                option.value = room;
                option.textContent = room;
                selector.appendChild(option);
            });

            selector.onchange = () => {
                currentRoom = selector.value;
                loadRoomData();
                redrawCanvas();
            };
        }

        function setCanvasMode(mode) {
            canvasMode = mode;
            document.querySelectorAll('.canvas-btn').forEach(btn => btn.classList.remove('active'));
            const modeBtn = document.getElementById(`${mode}Btn`);
            if (modeBtn) {
                modeBtn.classList.add('active');
            }

            // Set cursor based on mode
            const cursors = {
                'draw': 'crosshair',
                'rectangle': 'crosshair',
                'item': 'pointer'
            };
            canvas.style.cursor = cursors[mode] || 'default';

            // Deselect any selected rectangle when changing modes
            selectedRectangle = null;
            redrawCanvas();
        }

        function handleTouch(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];

            if (!touch) return;

            const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

            // Create synthetic mouse event
            const syntheticEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                offsetX: x,
                offsetY: y,
                preventDefault: () => {},
                button: 0
            };

            if (e.type === 'touchstart') {
                handleCanvasMouseDown(syntheticEvent);
            } else if (e.type === 'touchmove') {
                handleCanvasMouseMove(syntheticEvent);
            } else if (e.type === 'touchend') {
                handleCanvasMouseUp(syntheticEvent);
            }
        }

        function handleCanvasMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            startX = x;
            startY = y;

            if (canvasMode === 'draw') {
                isDrawing = true;
                ctx.beginPath();
                ctx.moveTo(x, y);
            } else if (canvasMode === 'rectangle') {
                // Check if clicking on existing rectangle
                const clickedRect = getRectangleAt(x, y);
                if (clickedRect) {
                    selectedRectangle = clickedRect;
                    // Check if clicking on resize handle
                    const handle = getResizeHandle(x, y, clickedRect);
                    if (handle) {
                        isResizing = true;
                        resizeHandle = handle;
                    } else {
                        isDragging = true;
                    }
                } else {
                    // Start drawing new rectangle
                    isDrawing = true;
                    selectedRectangle = {
                        x: x,
                        y: y,
                        width: 0,
                        height: 0,
                        name: '',
                        id: generateId('RECT')
                    };
                }
                redrawCanvas();
            } else if (canvasMode === 'item') {
                // Place item on canvas
                const itemName = prompt('Welcher Gegenstand soll hier platziert werden?');
                if (itemName) {
                    placeItemOnCanvas(x, y, itemName);
                }
            }
        }

        function handleCanvasMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            if (canvasMode === 'draw' && isDrawing) {
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.strokeStyle = '#2563eb';
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            } else if (canvasMode === 'rectangle') {
                if (isDrawing && selectedRectangle) {
                    // Update rectangle size
                    selectedRectangle.width = x - selectedRectangle.x;
                    selectedRectangle.height = y - selectedRectangle.y;
                    redrawCanvas();
                } else if (isDragging && selectedRectangle) {
                    // Move rectangle
                    const deltaX = x - startX;
                    const deltaY = y - startY;
                    selectedRectangle.x += deltaX;
                    selectedRectangle.y += deltaY;
                    startX = x;
                    startY = y;
                    redrawCanvas();
                } else if (isResizing && selectedRectangle && resizeHandle) {
                    // Resize rectangle
                    resizeRectangle(selectedRectangle, resizeHandle, x, y);
                    redrawCanvas();
                }
            }
        }

        function handleCanvasMouseUp(e) {
            if (canvasMode === 'draw' && isDrawing) {
                isDrawing = false;
                ctx.beginPath();
                saveCanvasState();
            } else if (canvasMode === 'rectangle') {
                if (isDrawing && selectedRectangle) {
                    // Normalize rectangle (handle negative width/height)
                    if (selectedRectangle.width < 0) {
                        selectedRectangle.x += selectedRectangle.width;
                        selectedRectangle.width = Math.abs(selectedRectangle.width);
                    }
                    if (selectedRectangle.height < 0) {
                        selectedRectangle.y += selectedRectangle.height;
                        selectedRectangle.height = Math.abs(selectedRectangle.height);
                    }

                    // Only add if rectangle has meaningful size
                    if (selectedRectangle.width > 10 && selectedRectangle.height > 10) {
                        const name = prompt('Name f√ºr diesen Bereich:') || `Bereich ${rectangles.length + 1}`;
                        selectedRectangle.name = name;
                        addRectangle(selectedRectangle);
                    }

                    isDrawing = false;
                    redrawCanvas();
                    saveCanvasState();
                }
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            }
        }

        function handleCanvasClick(e) {
            if (canvasMode === 'rectangle') {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);

                const clickedRect = getRectangleAt(x, y);
                if (clickedRect && clickedRect === selectedRectangle) {
                    // Double-click to rename
                    const newName = prompt('Neuer Name:', clickedRect.name);
                    if (newName !== null) {
                        clickedRect.name = newName;
                        redrawCanvas();
                        saveCanvasState();
                    }
                }
            }
        }

        function getRectangleAt(x, y) {
            return rectangles.find(rect =>
                x >= rect.x && x <= rect.x + rect.width &&
                y >= rect.y && y <= rect.y + rect.height
            );
        }

        function getResizeHandle(x, y, rect) {
            const handleSize = 10;
            const handles = {
                'nw': { x: rect.x - handleSize/2, y: rect.y - handleSize/2 },
                'ne': { x: rect.x + rect.width - handleSize/2, y: rect.y - handleSize/2 },
                'sw': { x: rect.x - handleSize/2, y: rect.y + rect.height - handleSize/2 },
                'se': { x: rect.x + rect.width - handleSize/2, y: rect.y + rect.height - handleSize/2 }
            };

            for (const [handle, pos] of Object.entries(handles)) {
                if (x >= pos.x && x <= pos.x + handleSize &&
                    y >= pos.y && y <= pos.y + handleSize) {
                    return handle;
                }
            }
            return null;
        }

        function resizeRectangle(rect, handle, x, y) {
            switch (handle) {
                case 'nw':
                    const newWidth = rect.width + (rect.x - x);
                    const newHeight = rect.height + (rect.y - y);
                    if (newWidth > 10) {
                        rect.width = newWidth;
                        rect.x = x;
                    }
                    if (newHeight > 10) {
                        rect.height = newHeight;
                        rect.y = y;
                    }
                    break;
                case 'ne':
                    rect.width = x - rect.x;
                    const newHeight2 = rect.height + (rect.y - y);
                    if (newHeight2 > 10) {
                        rect.height = newHeight2;
                        rect.y = y;
                    }
                    break;
                case 'sw':
                    const newWidth3 = rect.width + (rect.x - x);
                    if (newWidth3 > 10) {
                        rect.width = newWidth3;
                        rect.x = x;
                    }
                    rect.height = y - rect.y;
                    break;
                case 'se':
                    rect.width = x - rect.x;
                    rect.height = y - rect.y;
                    break;
            }
        }

        function addRectangle(rect) {
            rectangles.push(rect);
        }

        function placeItemOnCanvas(x, y, itemName) {
            ctx.fillStyle = '#059669';
            ctx.fillRect(x - 5, y - 5, 10, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText(itemName, x + 10, y + 5);
            saveCanvasState();
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            rectangles = [];
            selectedRectangle = null;
            saveCanvasState();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw saved canvas content first
            if (currentRoom && roomLayouts[currentRoom] && roomLayouts[currentRoom].imageData) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    drawRectangles();
                };
                img.src = roomLayouts[currentRoom].imageData;
            } else {
                drawRectangles();
            }
        }

        function drawRectangles() {
            rectangles.forEach(rect => {
                // Draw rectangle
                ctx.strokeStyle = rect === selectedRectangle ? '#dc2626' : '#2563eb';
                ctx.lineWidth = rect === selectedRectangle ? 3 : 2;
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

                // Fill with semi-transparent color
                ctx.fillStyle = rect === selectedRectangle ? 'rgba(220, 38, 38, 0.1)' : 'rgba(37, 99, 235, 0.1)';
                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);

                // Draw name
                ctx.fillStyle = '#000';
                ctx.font = '14px Arial';
                ctx.fillText(rect.name, rect.x + 5, rect.y + 20);

                // Draw resize handles for selected rectangle
                if (rect === selectedRectangle) {
                    drawResizeHandles(rect);
                }
            });
        }

        function drawResizeHandles(rect) {
            const handleSize = 10;
            const handles = [
                { x: rect.x - handleSize/2, y: rect.y - handleSize/2 }, // nw
                { x: rect.x + rect.width - handleSize/2, y: rect.y - handleSize/2 }, // ne
                { x: rect.x - handleSize/2, y: rect.y + rect.height - handleSize/2 }, // sw
                { x: rect.x + rect.width - handleSize/2, y: rect.y + rect.height - handleSize/2 } // se
            ];

            ctx.fillStyle = '#2563eb';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;

            handles.forEach(handle => {
                ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
                ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
            });
        }

        function saveCanvasState() {
            if (currentRoom) {
                if (!roomLayouts[currentRoom]) {
                    roomLayouts[currentRoom] = {};
                }
                roomLayouts[currentRoom].imageData = canvas.toDataURL();
                roomLayouts[currentRoom].rectangles = [...rectangles];
                saveData();
            }
        }

        function loadRoomData() {
            rectangles = [];
            selectedRectangle = null;

            if (currentRoom && roomLayouts[currentRoom]) {
                rectangles = roomLayouts[currentRoom].rectangles || [];
            }
        }

        // ==================== AUTO EXPORT SYSTEM ====================
        function autoExportData() {
            if (!settings.autoExport) return;

            try {
                const exportData = {
                    inventory: inventory,
                    settings: settings,
                    roomLayouts: roomLayouts,
                    idCounter: idCounter,
                    exportDate: new Date().toISOString(),
                    version: '4.0'
                };

                localStorage.setItem('last_auto_export', JSON.stringify(exportData, null, 2));
                log('Auto-export completed');
            } catch (error) {
                log(`Auto-export failed: ${error.message}`);
            }
        }

        // ==================== NETWORK SYNC SYSTEM ====================
        function startSyncServer() {
            // Simplified sync using broadcast channel and localStorage
            try {
                if (syncConnection) {
                    syncConnection.close();
                }

                syncConnection = new BroadcastChannel('inventory_sync');

                syncConnection.onmessage = (event) => {
                    const { type, data, deviceId } = event.data;

                    if (type === 'sync_request') {
                        // Send our data to requesting device
                        const response = {
                            type: 'sync_response',
                            data: {
                                inventory: inventory,
                                settings: settings,
                                roomLayouts: roomLayouts,
                                idCounter: idCounter,
                                exportDate: new Date().toISOString(),
                                version: '4.0'
                            },
                            deviceId: generateDeviceId()
                        };
                        syncConnection.postMessage(response);
                        updateSyncStatus('online', 'Daten gesendet');
                    } else if (type === 'sync_response') {
                        // Offer to import received data
                        showSyncImportDialog(data, deviceId);
                    } else if (type === 'device_announcement') {
                        addAvailableDevice(deviceId);
                    }
                };

                // Announce our presence
                syncConnection.postMessage({
                    type: 'device_announcement',
                    deviceId: generateDeviceId()
                });

                updateSyncStatus('online', 'Sync-Server aktiv');
                showNotification('Sync-Server gestartet! Andere Ger√§te k√∂nnen jetzt verbinden.', 'success');

            } catch (error) {
                updateSyncStatus('offline', 'Sync-Fehler');
                showNotification('Sync-Server konnte nicht gestartet werden', 'error');
                log(`Sync error: ${error.message}`);
            }
        }

        function searchForSyncDevices() {
            if (!syncConnection) {
                startSyncServer();
                return;
            }

            updateSyncStatus('syncing', 'Suche Ger√§te...');

            // Request sync from all devices
            syncConnection.postMessage({
                type: 'sync_request',
                deviceId: generateDeviceId()
            });

            setTimeout(() => {
                updateSyncStatus('online', 'Suche abgeschlossen');
            }, 3000);
        }

        function generateDeviceId() {
            if (!localStorage.getItem('device_id')) {
                localStorage.setItem('device_id', 'device_' + Math.random().toString(36).substr(2, 9));
            }
            return localStorage.getItem('device_id');
        }

        function updateSyncStatus(status, message) {
            const indicator = document.getElementById('syncStatus');
            if (!indicator) return;

            indicator.className = `sync-indicator ${status}`;

            const statusIcons = {
                online: 'üü¢',
                offline: 'üî¥',
                syncing: 'üü°'
            };

            indicator.textContent = `${statusIcons[status]} ${message}`;
        }

        function addAvailableDevice(deviceId) {
            const container = document.getElementById('availableDevices');
            if (!container) return;

            if (deviceId === generateDeviceId()) return; // Don't show ourselves

            const existingDevice = document.getElementById(`device_${deviceId}`);
            if (existingDevice) return; // Device already listed

            const deviceDiv = document.createElement('div');
            deviceDiv.id = `device_${deviceId}`;
            deviceDiv.style.cssText = 'padding: 0.5rem; margin: 0.5rem 0; background: var(--surface-alt); border-radius: var(--radius); display: flex; justify-content: space-between; align-items: center;';

            deviceDiv.innerHTML = `
                <span>üì± ${deviceId}</span>
                <button class="btn btn-secondary" onclick="requestSyncFromDevice('${deviceId}')" style="padding: 0.25rem 0.5rem;">üì• Sync anfragen</button>
            `;

            container.appendChild(deviceDiv);
        }

        function requestSyncFromDevice(deviceId) {
            if (!syncConnection) return;

            syncConnection.postMessage({
                type: 'sync_request',
                targetDevice: deviceId,
                deviceId: generateDeviceId()
            });

            updateSyncStatus('syncing', 'Sync angefragt...');
        }

        function showSyncImportDialog(data, fromDeviceId) {
            const shouldImport = confirm(`Sync-Daten von ${fromDeviceId} empfangen!\n\nM√∂chtest du diese Daten importieren?\n\n‚ö†Ô∏è Warnung: Aktuelle Daten werden √ºberschrieben!`);

            if (shouldImport) {
                importSyncData(data);
                showNotification('Sync-Daten erfolgreich importiert!', 'success');
            } else {
                showNotification('Sync abgebrochen', 'info');
            }
        }

        function importSyncData(data) {
            try {
                if (data.inventory) inventory = data.inventory;
                if (data.settings) settings = {...settings, ...data.settings};
                if (data.roomLayouts) roomLayouts = data.roomLayouts;
                if (data.idCounter) idCounter = Math.max(idCounter, data.idCounter);

                saveData();
                applySettings();
                updateUI();

                showNotification('Synchronisation abgeschlossen!', 'success');
            } catch (error) {
                showNotification('Fehler beim Importieren der Sync-Daten', 'error');
                log(`Sync import error: ${error.message}`);
            }
        }

        // ==================== UI MANAGEMENT ====================
        function setStatus(state, text) {
            const statusEl = document.getElementById('status');
            const micBtn = document.getElementById('micBtn');

            if (statusEl) statusEl.textContent = text;
            if (micBtn) micBtn.className = `mic-button ${state}`;

            if (settings.debugMode) {
                log(`Status: ${state} - ${text}`);
            }
        }

        function showNotification(message, type = 'info') {
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 4000);
        }

        function highlightResult(result) {
            const existing = document.querySelector('.result-highlight');
            if (existing) {
                existing.remove();
            }

            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-highlight';

            const idDisplay = settings.showIds ? `<small style="opacity: 0.8;">(ID: ${result.id})</small><br>` : '';
            const categoryDisplay = result.category ? `<small style="opacity: 0.8;">Kategorie: ${result.category}</small><br>` : '';

            resultDiv.innerHTML = `
                <strong>üéØ Gefunden!</strong><br>
                <strong>${result.item}</strong> ${idDisplay}${categoryDisplay}
                Standort: ${result.path.join(' ‚Üí ')}
            `;

            const container = document.querySelector('.container');
            if (container && container.children.length > 2) {
                container.insertBefore(resultDiv, container.children[2]);
            }

            setTimeout(() => {
                if (resultDiv.parentNode) {
                    resultDiv.remove();
                }
            }, 6000);
        }

        function toggleSection(sectionId) {
            const content = document.getElementById(`${sectionId}-content`);
            if (!content) return;

            const header = content.previousElementSibling;
            const icon = header ? header.querySelector('.expand-icon') : null;

            if (content.classList.contains('active')) {
                content.classList.remove('active');
                if (icon) icon.classList.remove('expanded');
            } else {
                content.classList.add('active');
                if (icon) icon.classList.add('expanded');
            }
        }

        // ==================== ENHANCED INVENTORY DISPLAY WITH DROPDOWNS ====================
        function renderInventory() {
            if (Object.keys(currentFilters).length > 0) {
                renderFilteredInventory();
                return;
            }

            const tree = document.getElementById('inventoryTree');
            if (!tree) return;

            tree.innerHTML = '';

            if (Object.keys(inventory).length === 0) {
                tree.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 2rem;">Noch keine Gegenst√§nde vorhanden</p>';
                return;
            }

            function renderNode(obj, path = [], level = 0) {
                for (const [key, value] of Object.entries(obj)) {
                    if (key === '_items' || key === '_meta' || key.endsWith('_meta')) continue;

                    const nodeId = path.concat(key).join('/');
                    const isExpanded = expandedNodes.has(nodeId);

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'tree-item';

                    const nodeHeader = document.createElement('div');
                    nodeHeader.className = `tree-node tree-indent-${level}`;
                    nodeHeader.onclick = () => toggleNode(nodeId);

                    const hasChildren = typeof value === 'object' && !Array.isArray(value) &&
                                       Object.keys(value).filter(k => !k.startsWith('_') && !k.endsWith('_meta')).length > 0;
                    const hasItems = (Array.isArray(value) && value.length > 0) ||
                                    (typeof value === 'object' && value._items && value._items.length > 0);

                    const expandIcon = (hasChildren || hasItems) ? (isExpanded ? '‚ñº' : '‚ñ∂') : '‚Ä¢';

                    const icon = level === 0 ? 'üè†' : level === 1 ? 'ü™ë' : level === 2 ? 'üì¶' : 'üìÑ';

                    const meta = obj[`${key}_meta`] || (typeof value === 'object' ? value._meta : null);
                    const idDisplay = settings.showIds && meta ? `<span class="id-badge">${meta.id}</span>` : '';

                    nodeHeader.innerHTML = `
                        <span class="expand-icon ${isExpanded ? 'expanded' : ''}">${expandIcon}</span>
                        <span>${icon} ${key}${idDisplay}</span>
                    `;

                    nodeDiv.appendChild(nodeHeader);

                    // Items dropdown for arrays
                    if (Array.isArray(value) && value.length > 0) {
                        const itemsDropdown = document.createElement('div');
                        itemsDropdown.className = `items-dropdown ${isExpanded ? 'active' : ''}`;

                        value.forEach(item => {
                            const itemEntry = document.createElement('div');
                            itemEntry.className = 'item-entry';

                            if (typeof item === 'object') {
                                const itemIdDisplay = settings.showIds ? `<span class="id-badge">${item.id}</span>` : '';
                                const categoryDisplay = item.category ? `<span class="category-badge">${item.category}</span>` : '';
                                const photoThumbnail = item.photo ? `<img src="${item.photo}" class="thumbnail" alt="Foto">` : '';

                                itemEntry.innerHTML = `
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        ${photoThumbnail}
                                        <span>üìã ${item.name}${itemIdDisplay}${categoryDisplay}</span>
                                    </div>
                                `;

                                itemEntry.onclick = (e) => {
                                    e.stopPropagation();
                                    showItemDetail({...item, path: path.concat(key)});
                                };

                                // Add properties display
                                if (item.properties && Object.keys(item.properties).length > 0) {
                                    const propertiesDiv = document.createElement('div');
                                    propertiesDiv.className = 'properties-display';
                                    propertiesDiv.style.marginTop = '0.5rem';

                                    Object.entries(item.properties).forEach(([propKey, propValue]) => {
                                        const propertyDiv = document.createElement('div');
                                        propertyDiv.className = 'property-item';

                                        let fillClass = 'medium';
                                        if (propValue <= 25) fillClass = 'low';
                                        else if (propValue >= 75) fillClass = 'high';

                                        propertyDiv.innerHTML = `
                                            <span class="property-name">${propKey}</span>
                                            <div class="property-value">
                                                <div class="progress-bar">
                                                    <div class="progress-fill ${fillClass}" style="width: ${propValue}%"></div>
                                                </div>
                                                <span style="font-size: 0.7rem;">${propValue}%</span>
                                            </div>
                                        `;

                                        propertiesDiv.appendChild(propertyDiv);
                                    });

                                    itemEntry.appendChild(propertiesDiv);
                                }
                            } else {
                                itemEntry.innerHTML = `<span>üìã ${item}</span>`;
                            }

                            itemsDropdown.appendChild(itemEntry);
                        });

                        nodeDiv.appendChild(itemsDropdown);
                    }

                    // Items from _items property
                    if (typeof value === 'object' && value._items && value._items.length > 0) {
                        const itemsDropdown = document.createElement('div');
                        itemsDropdown.className = `items-dropdown ${isExpanded ? 'active' : ''}`;

                        value._items.forEach(item => {
                            const itemEntry = document.createElement('div');
                            itemEntry.className = 'item-entry';

                            if (typeof item === 'object') {
                                const itemIdDisplay = settings.showIds ? `<span class="id-badge">${item.id}</span>` : '';
                                const categoryDisplay = item.category ? `<span class="category-badge">${item.category}</span>` : '';
                                const photoThumbnail = item.photo ? `<img src="${item.photo}" class="thumbnail" alt="Foto">` : '';

                                itemEntry.innerHTML = `
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        ${photoThumbnail}
                                        <span>üìã ${item.name}${itemIdDisplay}${categoryDisplay}</span>
                                    </div>
                                `;

                                itemEntry.onclick = (e) => {
                                    e.stopPropagation();
                                    showItemDetail({...item, path: path.concat(key)});
                                };

                                // Add properties display
                                if (item.properties && Object.keys(item.properties).length > 0) {
                                    const propertiesDiv = document.createElement('div');
                                    propertiesDiv.className = 'properties-display';
                                    propertiesDiv.style.marginTop = '0.5rem';

                                    Object.entries(item.properties).forEach(([propKey, propValue]) => {
                                        const propertyDiv = document.createElement('div');
                                        propertyDiv.className = 'property-item';

                                        let fillClass = 'medium';
                                        if (propValue <= 25) fillClass = 'low';
                                        else if (propValue >= 75) fillClass = 'high';

                                        propertyDiv.innerHTML = `
                                            <span class="property-name">${propKey}</span>
                                            <div class="property-value">
                                                <div class="progress-bar">
                                                    <div class="progress-fill ${fillClass}" style="width: ${propValue}%"></div>
                                                </div>
                                                <span style="font-size: 0.7rem;">${propValue}%</span>
                                            </div>
                                        `;

                                        propertiesDiv.appendChild(propertyDiv);
                                    });

                                    itemEntry.appendChild(propertiesDiv);
                                }
                            } else {
                                itemEntry.innerHTML = `<span>üìã ${item}</span>`;
                            }

                            itemsDropdown.appendChild(itemEntry);
                        });

                        nodeDiv.appendChild(itemsDropdown);
                    }

                    // Render child nodes
                    if (typeof value === 'object' && !Array.isArray(value) && isExpanded) {
                        const childContainer = document.createElement('div');
                        renderNodeInContainer(value, path.concat(key), level + 1, childContainer);
                        nodeDiv.appendChild(childContainer);
                    }

                    tree.appendChild(nodeDiv);
                }
            }

            function renderNodeInContainer(obj, path, level, container) {
                for (const [key, value] of Object.entries(obj)) {
                    if (key === '_items' || key === '_meta' || key.endsWith('_meta')) continue;

                    const nodeId = path.concat(key).join('/');
                    const isExpanded = expandedNodes.has(nodeId);

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'tree-item';

                    const nodeHeader = document.createElement('div');
                    nodeHeader.className = `tree-node tree-indent-${level}`;
                    nodeHeader.onclick = () => toggleNode(nodeId);

                    const hasChildren = typeof value === 'object' && !Array.isArray(value) &&
                                       Object.keys(value).filter(k => !k.startsWith('_') && !k.endsWith('_meta')).length > 0;
                    const hasItems = (Array.isArray(value) && value.length > 0) ||
                                    (typeof value === 'object' && value._items && value._items.length > 0);

                    const expandIcon = (hasChildren || hasItems) ? (isExpanded ? '‚ñº' : '‚ñ∂') : '‚Ä¢';

                    const icon = level === 0 ? 'üè†' : level === 1 ? 'ü™ë' : level === 2 ? 'üì¶' : 'üìÑ';

                    const meta = obj[`${key}_meta`] || (typeof value === 'object' ? value._meta : null);
                    const idDisplay = settings.showIds && meta ? `<span class="id-badge">${meta.id}</span>` : '';

                    nodeHeader.innerHTML = `
                        <span class="expand-icon ${isExpanded ? 'expanded' : ''}">${expandIcon}</span>
                        <span>${icon} ${key}${idDisplay}</span>
                    `;

                    nodeDiv.appendChild(nodeHeader);

                    // Items dropdown for arrays
                    if (Array.isArray(value) && value.length > 0) {
                        const itemsDropdown = document.createElement('div');
                        itemsDropdown.className = `items-dropdown ${isExpanded ? 'active' : ''}`;

                        value.forEach(item => {
                            const itemEntry = document.createElement('div');
                            itemEntry.className = 'item-entry';

                            if (typeof item === 'object') {
                                const itemIdDisplay = settings.showIds ? `<span class="id-badge">${item.id}</span>` : '';
                                const categoryDisplay = item.category ? `<span class="category-badge">${item.category}</span>` : '';
                                const photoThumbnail = item.photo ? `<img src="${item.photo}" class="thumbnail" alt="Foto">` : '';

                                itemEntry.innerHTML = `
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        ${photoThumbnail}
                                        <span>üìã ${item.name}${itemIdDisplay}${categoryDisplay}</span>
                                    </div>
                                `;

                                itemEntry.onclick = (e) => {
                                    e.stopPropagation();
                                    showItemDetail({...item, path: path.concat(key)});
                                };
                            } else {
                                itemEntry.innerHTML = `<span>üìã ${item}</span>`;
                            }

                            itemsDropdown.appendChild(itemEntry);
                        });

                        nodeDiv.appendChild(itemsDropdown);
                    }

                    // Render child nodes
                    if (typeof value === 'object' && !Array.isArray(value) && isExpanded) {
                        const childContainer = document.createElement('div');
                        renderNodeInContainer(value, path.concat(key), level + 1, childContainer);
                        nodeDiv.appendChild(childContainer);
                    }

                    container.appendChild(nodeDiv);
                }
            }

            renderNode(inventory);
        }

        function toggleNode(nodeId) {
            if (expandedNodes.has(nodeId)) {
                expandedNodes.delete(nodeId);
            } else {
                expandedNodes.add(nodeId);
            }
            renderInventory();
        }

        function toggleExpandAll() {
            if (allExpanded) {
                expandedNodes.clear();
                expandedItems.clear();
            } else {
                function addAllNodes(obj, path = []) {
                    for (const [key, value] of Object.entries(obj)) {
                        if (!key.startsWith('_') && !key.endsWith('_meta')) {
                            const nodeId = path.concat(key).join('/');
                            expandedNodes.add(nodeId);
                            expandedItems.add(nodeId);
                            if (typeof value === 'object' && !Array.isArray(value)) {
                                addAllNodes(value, path.concat(key));
                            }
                        }
                    }
                }
                addAllNodes(inventory);
            }
            allExpanded = !allExpanded;
            renderInventory();
        }

        // ==================== STATISTICS ====================
        function updateStats() {
            let totalItems = 0;
            let totalRooms = 0;
            let totalContainers = 0;

            function countItems(obj, level = 0) {
                for (const [key, value] of Object.entries(obj)) {
                    if (key === '_items') {
                        totalItems += value.length;
                    } else if (key.endsWith('_meta')) {
                        if (value.type === 'room') totalRooms++;
                        else if (value.type === 'container') totalContainers++;
                    } else if (Array.isArray(value)) {
                        totalItems += value.length;
                        if (level > 0) totalContainers++;
                    } else if (typeof value === 'object') {
                        if (level === 0) totalRooms++;
                        else if (level > 0) totalContainers++;
                        countItems(value, level + 1);
                    }
                }
            }

            countItems(inventory);

            const totalItemsEl = document.getElementById('totalItems');
            const totalRoomsEl = document.getElementById('totalRooms');
            const totalContainersEl = document.getElementById('totalContainers');

            if (totalItemsEl) totalItemsEl.textContent = totalItems;
            if (totalRoomsEl) totalRoomsEl.textContent = totalRooms;
            if (totalContainersEl) totalContainersEl.textContent = totalContainers;
        }

        // ==================== SETTINGS MANAGEMENT ====================
        function saveSettings() {
            // Read settings from UI
            const continuousListeningEl = document.getElementById('continuousListening');
            const speechRateEl = document.getElementById('speechRate');
            const speechVolumeEl = document.getElementById('speechVolume');
            const showIdsEl = document.getElementById('showIds');
            const autoSaveEl = document.getElementById('autoSave');
            const autoExportEl = document.getElementById('autoExport');
            const languageEl = document.getElementById('language');

            if (continuousListeningEl) settings.continuousListening = continuousListeningEl.checked;
            if (speechRateEl) settings.speechRate = parseFloat(speechRateEl.value);
            if (speechVolumeEl) settings.speechVolume = parseFloat(speechVolumeEl.value);
            if (showIdsEl) settings.showIds = showIdsEl.checked;
            if (autoSaveEl) settings.autoSave = autoSaveEl.checked;
            if (autoExportEl) settings.autoExport = autoExportEl.checked;
            if (languageEl) settings.language = languageEl.value;

            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings, null, 2));
            showNotification('Einstellungen gespeichert!', 'success');
            applySettings();
        }

        function updateCategories() {
            const categoriesEditEl = document.getElementById('categoriesEdit');
            if (!categoriesEditEl) return;

            const text = categoriesEditEl.value;
            settings.categories = text.split('\n').filter(line => line.trim()).map(line => line.trim());
            saveSettings();
            setupCategorySelector();
            showNotification('Kategorien aktualisiert!', 'success');
        }

        function updateProperties() {
            const propertiesEditEl = document.getElementById('propertiesEdit');
            if (!propertiesEditEl) return;

            const text = propertiesEditEl.value;
            settings.properties = text.split('\n').filter(line => line.trim()).map(line => line.trim().toLowerCase());
            saveSettings();
            setupPropertySliders();
            showNotification('Eigenschaften aktualisiert!', 'success');
        }

        function resetApp() {
            if (confirm('Alle Daten l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden!')) {
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(SETTINGS_KEY);
                localStorage.removeItem('room_layouts');
                localStorage.removeItem('id_counter');
                localStorage.removeItem('device_id');
                location.reload();
            }
        }

        // ==================== DATA IMPORT/EXPORT ====================
        function exportData() {
            const exportData = {
                inventory: inventory,
                settings: settings,
                roomLayouts: roomLayouts,
                idCounter: idCounter,
                exportDate: new Date().toISOString(),
                version: '4.0'
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `smart_inventar_backup_${new Date().toISOString().split('T')[0]}.json`;
            link.click();

            URL.revokeObjectURL(url);
            showNotification('Inventar exportiert!', 'success');
        }

        function importData() {
            const fileInput = document.getElementById('importFile');
            if (!fileInput) return;

            const file = fileInput.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);

                    if (importedData.version && importedData.inventory) {
                        inventory = importedData.inventory;
                        if (importedData.settings) {
                            settings = {...settings, ...importedData.settings};
                        }
                        if (importedData.roomLayouts) {
                            roomLayouts = importedData.roomLayouts;
                        }
                        if (importedData.idCounter) {
                            idCounter = Math.max(idCounter, importedData.idCounter);
                            localStorage.setItem('id_counter', idCounter.toString());
                        }
                    } else {
                        inventory = importedData;
                    }

                    saveData();
                    applySettings();
                    updateUI();
                    showNotification('Inventar importiert!', 'success');
                } catch (error) {
                    showNotification('Fehler beim Importieren: Ung√ºltiges Format', 'error');
                    log(`Import error: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        // ==================== THEME MANAGEMENT ====================
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // ==================== UTILITY FUNCTIONS ====================
        function log(message) {
            if (settings.debugMode) {
                console.log(`[Inventory] ${new Date().toLocaleTimeString()}: ${message}`);
            }
        }

        function updateUI() {
            renderInventory();
            updateStats();
            updateCategoryFilters();
            updateRoomSelector();
        }

        function getSuggestions(query) {
            const normalizedQuery = query.toLowerCase();
            const suggestions = [];

            function collectItems(obj) {
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        value.forEach(item => {
                            if (typeof item === 'object') {
                                suggestions.push({name: item.name, id: item.id});
                            } else {
                                suggestions.push({name: item, id: 'Legacy'});
                            }
                        });
                    } else if (typeof value === 'object') {
                        suggestions.push({name: key, id: 'Container'});
                        collectItems(value);
                    }
                }
            }

            collectItems(inventory);

            return suggestions
                .filter(item => item.name.toLowerCase().includes(normalizedQuery.substring(0, 3)))
                .slice(0, 3);
        }

        // ==================== EVENT LISTENERS ====================
        document.addEventListener('DOMContentLoaded', () => {
            const micBtn = document.getElementById('micBtn');
            if (micBtn) {
                micBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startActiveListening();
                });

                micBtn.addEventListener('click', () => {
                    if (isListening) {
                        if (recognition) recognition.stop();
                    } else {
                        startActiveListening();
                    }
                });
            }

            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleSearchInput();
                    }
                });
            }

            const itemDetailModal = document.getElementById('itemDetailModal');
            if (itemDetailModal) {
                itemDetailModal.addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        closeItemDetail();
                    }
                });
            }

            // Prevent zoom on input focus (mobile)
            document.querySelectorAll('input[type="text"], input[type="password"], select, textarea').forEach(input => {
                input.addEventListener('focus', () => {
                    const viewport = document.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
                    }
                });

                input.addEventListener('blur', () => {
                    const viewport = document.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=no');
                    }
                });
            });

            // Auto-export on page unload
            window.addEventListener('beforeunload', () => {
                if (settings.autoExport) {
                    autoExportData();
                }
            });

            // Initialize app
            init();
        });

        window.addEventListener('orientationchange', () => {
            setTimeout(updateUI, 500);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (recognition) recognition.stop();
                if (window.speechSynthesis) window.speechSynthesis.cancel();
            } else if (settings.continuousListening) {
                setTimeout(startWakeWordListening, 1000);
            }
        });

        // ==================== INITIALIZATION ====================
        function init() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);

            initSpeechRecognition();
            setupCategorySelector();
            setupPropertySliders();
            applySettings();
            updateStats();
            renderInventory();
            updateCategoryFilters();

            // Load settings into UI
            const settingsElements = {
                'continuousListening': settings.continuousListening,
                'speechRate': settings.speechRate,
                'speechVolume': settings.speechVolume,
                'showIds': settings.showIds,
                'autoSave': settings.autoSave,
                'autoExport': settings.autoExport,
                'language': settings.language
            };

            Object.entries(settingsElements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = value;
                    } else {
                        element.value = value;
                    }
                }
            });

            const categoriesEdit = document.getElementById('categoriesEdit');
            if (categoriesEdit) {
                categoriesEdit.value = settings.categories.join('\n');
            }

            const propertiesEdit = document.getElementById('propertiesEdit');
            if (propertiesEdit) {
                propertiesEdit.value = settings.properties.join('\n');
            }

            setStatus('idle', 'Bereit zum Lauschen');

            setTimeout(() => {
                showNotification('Smart Inventar Organizer Pro ist bereit! üé§üìäüè†', 'success');
                if (settings.continuousListening) {
                    showNotification('Wake Word aktiv: "Hey Organizer"', 'info');
                }
            }, 500);

            log('App initialized successfully');
        }
    </script>
</body>
</html>